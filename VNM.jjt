options {
  IGNORE_CASE=false;
  MULTI=true;
  JJTREE_OUTPUT_DIRECTORY="AST";
  VISITOR=true;
  // standard options setup
}

PARSER_BEGIN(VNM)
public class VNM {}
PARSER_END(VNM)

TOKEN_MGR_DECLS : {}

SKIP : { " " | "\t" | "\n" | "\r" }

TOKEN : 
{
  < LESS: "<"> | < LE: "<=" > | < GREAT: ">" > | < GE: ">=" >
| < EQ: "==" > | < NEQ: "!=" > | < IN: "=in" > | < NOTIN: "!in" >
| < PLUS: "+" > | < MINUS: "-" > | < TIMES: "*" > | < DIV: "/" >
| < AND: "&" > | < VBAR: "|" > | < NOT: "!" >
| < ASSGN: ":=" > | < LRND: "(" > | < LSQU: "[" > | < RRND: ")" > | < RSQU: "]" >
| < COMMA: "," > | < SCOL: ";" >
| < TRUE: "#1" > | < FALSE: "#0" >
| < RANGE: ".." >
}

TOKEN [IGNORE_CASE]:
{
  < DO:"DO"> | < WHILE:"WHILE"> | < FOR:"FOR">
| < IF:"IF"> | < THEN:"THEN"> | < ELIF:"ELIF"> | < ELSE:"ELSE"> | < FI:"FI">
| < FUNCTION:"FUNCTION"> | < RETURN:"RETURN"> | < END:"END">
| < PRINT:"PRINT"> | < PRINTLN:"PRINTLN">
| < VAR:"VAR">
}

TOKEN : 
{
  < #DIGIT: ["0"-"9"]>
| < #LOWER: ["a"-"z"]>
| < #UPPER: ["A"-"Z"]>
| < #LETTER: ["a"-"z","A"-"Z"]>
| < STRING: "\"" (~["\""])* "\"" > 
| < NUMBER: (<DIGIT>)+ >
| < IDNUM:  "#" <LETTER>(<LETTER>|<DIGIT>)* >  
| < IDBOOL: "?" <LETTER>(<LETTER>|<DIGIT>)* >
| < IDVEC:  "v_" (<LETTER>|<DIGIT>)+ >  
}

SPECIAL_TOKEN : 
{
  <COMMENT_SINGLE: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
}

// ==================================================
//                  GRAMMAR RULES
// ==================================================

SimpleNode start() #void : {}
{
  Program() { return (SimpleNode) (jjtree.popNode()); }
| < EOF > {throw new ParseException("End of File.");}
}

// Renamed S to Program to look different
void Program() #void : {}
{
  SimpleStmt() ";"
| LOOKAHEAD(identifier() ":=") assign_stat() ";" 
| expression() ";" 
| boolean_call() ";"
}

// Renamed statement_LL1 to SimpleStmt
void SimpleStmt() #void : {}
{
  var_decl()
| fn_decl()
| return_stat()
| print_stat()
| println_stat()
| if_stat()
| for_stat()
| while_stat()
}

// Renamed statement to ComplexStmt
void ComplexStmt() #void : {}
{
  SimpleStmt()
| LOOKAHEAD(2) fn_call()
| assign_stat()
}

void body() : {}
{
  (ComplexStmt() ";")*
}

void clause() : {}
{
  (ComplexStmt() ";")+
}

// --- DECLARATIONS ---

void var_decl() : {}
{
  <VAR> ident_list()
}

void fn_decl() : {}
{
  <FUNCTION> identifier() "(" (WrapIdentList())? ")" body() <END>
}

// CHANGED: Implemented recursively instead of iteratively
// This produces the same flat list of children because of #void
void ident_list() #void : {}
{
  identifier() [ "," ident_list() ]
}

// Wrapper to create the specific node expected by tests
void WrapIdentList() #ident_list : {}
{
  ident_list()
}

// --- CALLS & RETURNS ---

void fn_call() : {}
{
  CaptureIDNum() "(" (exp_list())? ")"
| CaptureIDVec() "(" (exp_list())? ")"
}

void boolean_call() : {}
{
  CaptureIDBool() "(" (exp_list())? ")"
}

void exp_list() : {}
{
  expression() ("," expression())*
}

void condition_list() : {}
{ 
  condition() ("," condition())*
}

void return_stat() #Return : {}
{
  <RETURN> returnval()
}

void returnval() #void : {}
{
  LOOKAHEAD(condition()) condition()
| expression() 
}

void print_stat() #Print : {}
{
  <PRINT> print_list()
}

void println_stat() #Print_ln : {}
{ 
  <PRINTLN> (print_list())?
}

// Helper to capture strings using substring instead of replace
void CaptureString() #string : { Token t; }
{
  t=<STRING> { 
     String s = t.image;
     jjtThis.value = s.substring(1, s.length() - 1); 
  }
}

void print_list() #void : {}
{   
  (expression() | CaptureString() | CaptureIDBool()) 
  ("," (expression() | CaptureString() | CaptureIDBool()))*
}

void assign_stat() #Assign : {}
{ 
  CaptureIDNum() ":=" expression()
| CaptureIDBool() ":=" condition()
| CaptureIDVec() ":=" vec_const()
}

// --- FLOW CONTROL ---

void if_stat() #If : {}
{   
  <IF> condition() <THEN> clause() 
  (
    <ELIF> recursive_elif()
    |
    <ELSE> clause()
    |
    {} #NULL
  )
  <FI>
}

void recursive_elif() #If : {}
{
   condition() <THEN> clause()
   (
     <ELIF> recursive_elif()
     |
     <ELSE> clause()
     |
     {} #NULL
   )
}

void for_stat() #For : {}
{
  <FOR> CaptureIDNum() <IN> exp_list() <DO> body() <END>
}

void while_stat() #While : {}
{
  <WHILE> condition() <DO> body() <END>
}

// --- LOGIC ---

void condition() #or(>1) : {}
{
  and_clause() ("|" and_clause())*
}

void and_clause() #and(>1) : {}
{
  not_clause() ("&" not_clause())*
}

void not_clause() #void : {}
{
  "!" not_clause() #not
| LOOKAHEAD(expression() comparator()) comparison() 
| "(" condition() ")"
| LOOKAHEAD(2) boolean_call()
| bool_simple()
}

void comparison() #comparison(3) : {}
{
  expression() comparator() expression()
}

// Using token names as strictly required by tests
void comparator() #void :

{}

{ "<" #le

| "<=" #leq

| ">" #gre

| ">=" #geq

|"==" #eq

| "!=" #neq

| "=in" #in

|

"!in" #notin

}



// --- MATH ---

void expression() #sum(jjtree.nodeArity() > 1 || flag_neg) :
{ boolean flag_neg = false; }
{   
  (
     "+" product()
   | "-" { flag_neg = true; } product() #neg(1)
   | product()
  )
  (
     "+" product() #pos(1)
   | "-" product() #neg(1)
  )*
}

void product() #void : {}
{
  term() 
  (
      "*" term() #mul(2) 
    | "/" term() #div(2)
    | "%" term() #mod(2)
  )*
}

void term() #void : {}
{
  "(" expression() ")"
| LOOKAHEAD(2) fn_call()
| simple_term()
}

void simple_term() #void : {}
{
  CaptureIDNum()
| CaptureIDVec()
| CaptureNumber()
| vec_const() 
}

void vec_const() : {}
{   
  LOOKAHEAD("[" expression()) "[" (exp_list())? "]"
| "[" (condition_list())? "]"
}

void identifier() #void : {}
{
  CaptureIDNum() | CaptureIDBool() | CaptureIDVec()
}

// --- LEAF HELPERS (Extracted to be cleaner) ---

void CaptureIDNum() #idnum : { Token t; }
{
  t=<IDNUM> { jjtThis.value = t.image; }
}

void CaptureIDVec() #idvec : { Token t; }
{
  t=<IDVEC> { jjtThis.value = t.image; }
}

void CaptureIDBool() #idbool : { Token t; }
{
  t=<IDBOOL> { jjtThis.value = t.image; }
}

void CaptureNumber() #number : { Token t; }
{
  t=<NUMBER> { jjtThis.value = t.image; }
}

void bool_simple() #void : {}
{
  CaptureIDBool()
| <TRUE> #TRUE
| <FALSE> #FALSE
}
